#include <stdio.h>#include <fcntl.h>#include <sys/stat.h>#include <time.h>#include <sys/time.h>#include "defValues.h"#include "../utils/bitmap.h"#include "../utils/huff.h"#include "../utils/parameters.h"#ifdef PSI_HUFFMANRLE	#include "psiHuffmanRLE.h"#endif#ifdef PSI_GONZALO	#include "psiGonzalo.h"#endif#ifdef PSI_DELTACODES	#include "psiDeltaCode.h"#endiftypedef struct {	uint suffixArraySize;	uint T_Psi;	uint *D;	bitmap bD;	uint T_A;	uint T_AInv;	uint *samplesA;	uint samplesASize;	uint *BA;	bitmap bBA;		uint *samplesAInv;	uint samplesAInvSize;	uint displayCSAState;	long displayCSAPrevPosition;	#ifdef PSI_HUFFMANRLE		HuffmanCompressedPsi hcPsi;	#endif		#ifdef PSI_GONZALO	GonzaloCompressedPsi gcPsi;	#endif	#ifdef PSI_DELTACODES	DeltaCompressedPsi dcPsi;	#endif		//only needed during "parse_parameters".	uint tempNSHUFF;	uint psiSearchFactorJump;  //factor of the T_Psi value.} ticsa;		// FUNCTION PROTOTYPES: BUILDING THE INDEX//Creates the ICSA		int buildIntIndex (uint *intVector, uint n, char *build_options, void **index ); //ticsa *createIntegerCSA (uint **aintVector, uint SAsize, char *build_options);//Returns number of elements in the indexed sequence of integers	int sourceLenIntIndex(void *index, uint *numInts);//Save the index to disk	int saveIntIndex(void *index, char *pathname); //void storeStructsCSA(ticsa *myicsa, char *basename);// Loads the index from disk.	int loadIntIndex(char *pathname, void **index);  //ticsa *loadCSA(char *basename);//  Frees memory		int freeIntIndex(void *index); //uint destroyStructsCSA(ticsa *myicsa);//Returns the size (in bytes) of the index over the sequence of integers.	int sizeIntIndex(void *index, uint *numBytes); //uint CSA_size(ticsa *myicsa);		// Shows detailed summary info of the self-index (memory usage of each structure)int printInfoIntIndex(void *index, const char tab[]);//Number of occurrences of the pattern, and the interval [left,right] in the suffix array.	int countIntIndex(void *index, uint *pattern, uint length, ulong *numocc, ulong *left, ulong *right);			//uint countCSA(ticsa *myicsa, uint *pattern, uint patternSize, uint *left, uint *right);		// Exponential search			//uint countCSABin(ticsa *myicsa, uint *pattern, uint patternSize, uint *left, uint *right);	// Binary search// Returns an array with integers corresponding offsets to the occurrences of the pattern, // as well as the number of occurrences	int locateIntIndex(void *index, uint *pattern, uint length, ulong **occ, ulong *numocc);		//uint *locateCSA(ticsa *myicsa, uint *pattern, uint patternSize, uint *occ);//Returns the value of the source (array of integers) at a given offset.// (that is, the element "position" from the original array of uints)	int displayIntIndex(void *index, ulong position, uint *value);		//uint displayCSA(ticsa *myicsa, uint position);	/* Private function prototypes ********************************************/uint parametersCSA(ticsa *myicsa, char *build_options);uint displayCSAFirst(ticsa *myicsa, uint position);uint displayCSANext(ticsa *myicsa);int  SadCSACompare(ticsa *myicsa, uint *pattern, uint patternSize, uint p);uint A(ticsa *myicsa, uint position);uint inverseA(ticsa *myicsa, uint offset);void showStructsCSA(ticsa *myicsa);		// For Debugging